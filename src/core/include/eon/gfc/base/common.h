//------------------------------------------------------------------------------
//                  The best method for accelerating a computer
//                     is the one that boosts it by 9.8 m/s2.
//------------------------------------------------------------------------------
// Published under the GPL3 license; see LICENSE for more information.
//------------------------------------------------------------------------------

#pragma once

/** \addtogroup engine
  * @{
  *   \addtogroup base
  *   @{
  *     \addtogroup macros
  *     @{
  */

//================================================+=============================
//Common:{                                        |
  //Aliases:{                                     |

    #ifdef __cplusplus
      template<typename T> using e_noconst_ptr = typename std::remove_pointer<typename std::remove_const<T>::type>::type;
      template<typename T> using e_noconst     = typename std::remove_const<T>::type;
    #endif

  //}:                                            |
  //Dialects:{                                    |

    #ifdef __OBJC__
      #define __compiling_objc__ 1
    #endif

    #ifdef __cplusplus
      #define __compiling_cpp__ 1
    #endif

    #ifdef __STDC__
      #define __compiling_c__ 1
    #endif

    #ifndef   __compiling_profiler__
      #define __compiling_profiler__ 0
    #endif

    #ifndef   __compiling_logging__
      #define __compiling_logging__ 0
    #endif

  //}:                                            |
  //Equates:{                                     |
    //Debugging:{                                 |

      #if defined DEBUG||defined _debug||defined _DEBUG||defined debug||defined __DEBUG__
        #define __compiling_sanity__ 0
        #define __compiling_debug__  1
      #endif

    //}:                                          |
    //STRICT:{                                    |

      #ifndef STRICT
        #define STRICT
      #endif

    //}:                                          |
    //NULL:{                                      |

      #ifndef NULL
        #define NULL 0L
      #endif

    //}:                                          |
  //}:                                            |
  //Macros:{                                      |
    //e_const:{                                   |

      #define e_consts( ... )                                                   \
        enum{__VA_ARGS__}                                                       \

    //}:                                          |
    //e_var_*:{                                   |
      //e_var_string_map:{                        |

        /** \brief Declare string map.
          *
          * This function macro will create a gfc map that uses strings for
          * keys.  It is a shortcut to adding all the accessors by hand.
          * Forever after the name of the variable in protected scope will be
          * m_mX where X is the name of the variable passed into the macro. The
          * following methods are generated by this macro if T=Texture::handle
          * and X=Textures: \param T The type of the values contained in the
          * string key:value pair.
          *
          * \param X The name of the string map, first letter capitalized.
          \code
            class MyClass{
              e_var_string_map( Texture::handle, TextureMap );//pun intended.
            };
          \endcode
          */

#define e_var_string_map( T, X )                                                \
  public:                                                                       \
    using X=::EON::gfc::hashmap<u64,T>;                                         \
    e_forceinline_always void setIn##X( const u64 key, const T& t ){            \
      m_m##X.set( key, t );                                                     \
    }                                                                           \
    e_forceinline_always void setBy##X( const u64 key                           \
        , const std::function<void( T& )>& lambda ){                            \
      m_m##X.setBy( key, lambda );                                              \
    }                                                                           \
    e_forceinline_always const T in##X( const u64 key )const{                   \
      return m_m##X[ key ];                                                     \
    }                                                                           \
    e_forceinline_always const X& to##X()const{                                 \
      return m_m##X;                                                            \
    }                                                                           \
    e_forceinline_always X& to##X(){                                            \
      return m_m##X;                                                            \
    }                                                                           \
    e_forceinline_always void clear##X(){                                       \
      m_m##X.clear();                                                           \
    }                                                                           \
  private:                                                                      \
    X m_m##X                                                                    \

#define e_var_string_map1( T )                                                  \
  e_var_string_map( T, T##s )                                                   \

      //}:                                        |
      //e_var_handle:{                            |

        /** \brief Define handle member variable.
          *
          * This macro declares a member variable of type handle. A handle in
          * this context refers to a gfc AutoRef template, which is usually
          * defined in a class as
          * <h4>Usage</h4>
          * The way to use the e_var_handle follows. <i>NB: Any class that will
          * be used as a handle <b>must</b> inherit the gfc::Object type and
          * specify the e_reflect() engine macro to hook the class up to the
          * reflection system.</i>
          \code
            struct MyObject:Object{
              e_reflect( MyObject, Object );
            };
            struct MyClass{
              e_var_handle1( MyObject );
            };
          \endcode
          * <h4>Expanded</h4>
          * Not only does the e_var\* family of macros define a type but also
          * the accessors that go along with them. These will be named set\*
          * and to\*.  The member variable itself is declared in Hungarian
          * notion: m_h* for handles.
          *
          * \param T An Object derived class type.
          * \param X The name of the new variable.
          */

#define e_var_handle( T, X )                                                    \
  public:                                                                       \
    e_forceinline_always void set##X( const::EON::gfc::AutoRef<T>& x ){         \
      m_h##X = x;                                                               \
    }                                                                           \
    e_forceinline_always bool is##X( const::EON::gfc::AutoRef<T>& ref )const{   \
      return( m_h##X == ref );                                                  \
    }                                                                           \
    e_forceinline_always const::EON::gfc::AutoRef<T>& to##X()const{             \
      return m_h##X;                                                            \
    }                                                                           \
    e_forceinline_always::EON::gfc::AutoRef<T>& to##X(){                        \
      return m_h##X;                                                            \
    }                                                                           \
  private:                                                                      \
    ::EON::gfc::AutoRef<T> m_h##X                                               \

        /** \brief Define handle member variable.
          *
          * This macro is used to define a handle member variable when the type
          * and name are the same.
          *
          * \param T The handle class; passed directly to AutoRef<T>.
          */

#define e_var_handle1( T )                                                      \
  e_var_handle( T, T )                                                          \

      //}:                                        |
      //e_var_string:{                            |

        /** \brief Declare string member variable.
          *
          * This function macro tames the usual C++ monkey business of creating
          * all the accessors for a var.  In additional to the standard set*
          * and to* is a special set that takes a C string; otherwise a
          * gfc::string.  The Hungarian name is m_sName. Like all e_var* macros
          * you can assign a non-static member variable a value as per C++11
          * standard like so:
          \code
            class MyClass{
              e_var_string( Path ) = "/src/data";
            public:
              MyClass() = default;
            };
          \endcode
          *
          * \param X The name of the new string.
          */

#define e_var_string( X )                                                       \
  public:                                                                       \
    e_forceinline_always char in##X( const u32 i )const{                        \
      return m_s##X[i];                                                         \
    }                                                                           \
    e_forceinline_always void set##X( const::EON::gfc::string& s ){             \
      m_s##X = s;                                                               \
    }                                                                           \
    e_forceinline_always void set##X(::EON::gfc::string&& s ){                  \
      m_s##X = std::move( s );                                                  \
    }                                                                           \
    e_forceinline_always void set##X( ccp s ){                                  \
      m_s##X = s;                                                               \
    }                                                                           \
    e_forceinline_always bool is##X( const::EON::gfc::string& str )const{       \
      return( m_s##X == str );                                                  \
    }                                                                           \
    e_forceinline_always const::EON::gfc::string& to##X()const{                 \
      return m_s##X;                                                            \
    }                                                                           \
    e_forceinline_always::EON::gfc::string& to##X(){                            \
      return m_s##X;                                                            \
    }                                                                           \
  private:                                                                      \
    ::EON::gfc::string m_s##X                                                   \

      //}:                                        |
      //e_var_buffer:{                            |

        /** \brief Declare buffer member variable.
          *
          * This function macro tames the usual C++ monkey business of creating
          * all the accessors for a buffer. The macro will generate the
          * following member functions for you if X=Maps:
          */

#define e_var_buffer( X )                                                       \
  public:                                                                       \
    typedef::EON::gfc::buffer X;                                                \
    e_forceinline_always void set##X( const X& x ){                             \
      m_t##X = x;                                                               \
    }                                                                           \
    e_forceinline_always bool is##X( const::EON::gfc::buffer& buf )const{       \
      return( m_t##X == buf );                                                  \
    }                                                                           \
    e_forceinline_always const X& to##X()const{                                 \
      return m_t##X;                                                            \
    }                                                                           \
    e_forceinline_always X& to##X(){                                            \
      return m_t##X;                                                            \
    }                                                                           \
  private:                                                                      \
    ::EON::gfc::buffer m_t##X                                                   \

      //}:                                        |
      //e_var_vector:{                            |

        /** \brief Define vector var.
          *
          * This macro will create a vector member variable. It is identical in
          * many ways to e_var_handle() but also adds a in* function that takes
          * an integer index, which returns an element of the vector. The
          * following methods are created for you if T equals string and X
          * equals Strings or in other words e_var_vector( string, Strings );
          *
          * \param T The type of each element in the new vector variable.
          * \param X The name of the undecorated variable.
          */

#define e_var_vector( T, X )                                                    \
  public:                                                                       \
    using X=::EON::gfc::vector<T>;                                              \
    template<typename C> e_forceinline_always bool sort##X(                     \
          const std::function<C>& lambda ){                                     \
      return m_v##X.sort( lambda );                                             \
    }                                                                           \
    template<typename C> e_forceinline_always bool sort##X( const C& functor ){ \
      return m_v##X.sort( functor );                                            \
    }                                                                           \
    template<typename E> e_forceinline_always void setIn##X( const E e,         \
        const T& t ){                                                           \
      m_v##X.set( e, t );                                                       \
    }                                                                           \
    template<typename E> e_forceinline_always const T& in##X( const E e )const{ \
      return m_v##X[ e ];                                                       \
    }                                                                           \
    e_forceinline_always void set##X( const X& v##X ){                          \
      m_v##X = v##X;                                                            \
    }                                                                           \
    e_forceinline_always void set##X( X&& v##X ){                               \
      m_v##X = std::move( v##X );                                               \
    }                                                                           \
    e_forceinline_always const X& to##X()const{                                 \
      return m_v##X;                                                            \
    }                                                                           \
    e_forceinline_always X& to##X(){                                            \
      return m_v##X;                                                            \
    }                                                                           \
    e_forceinline_always void clear##X(){                                       \
      m_v##X.clear();                                                           \
    }                                                                           \
  private:                                                                      \
    X m_v##X                                                                    \

#define e_var_vector1( T )                                                      \
  e_var_vector( T, T##s )                                                       \

      //}:                                        |
      //e_var_array:{                             |

        /** \brief Declare a gfc array.
          *
          * This macro will define a gfc array.
          */

#define e_var_array( T, X, N )                                                  \
  public:                                                                       \
    using X=::EON::gfc::array<T,u32( N )>;                                      \
    static const u32 k##X##Capacity = u32( N );                                 \
    e_forceinline_always void set##X( const X& a##X ){                          \
      m_a##X = a##X;                                                            \
    }                                                                           \
    e_forceinline_always void set##X( X&& a##X ){                               \
      m_a##X = std::move( a##X );                                               \
    }                                                                           \
    template<typename E> e_forceinline_always void setIn##X( const E e,         \
        const T& t ){                                                           \
      m_a##X[ u32( e )] = t;                                                    \
    }                                                                           \
    template<typename E> e_forceinline_always const T& in##X( const E e )const{ \
      return m_a##X[ u32( e )];                                                 \
    }                                                                           \
    template<typename E> e_forceinline_always T& in##X( const E e ){            \
      return m_a##X[ u32( e )];                                                 \
    }                                                                           \
    e_forceinline_always const X& to##X()const{                                 \
      return m_a##X;                                                            \
    }                                                                           \
    e_forceinline_always X& to##X(){                                            \
      return m_a##X;                                                            \
    }                                                                           \
  private:                                                                      \
    X m_a##X                                                                    \

#define e_var_array1( T, N )                                                    \
  e_var_array( T, T##s, N )                                                     \

      //}:                                        |
      //e_var_dim:{                               |

        /** \brief Declare a C array.
          *
          * This macro will define a regular C array.
          */

#define e_var_dim( T, X, N )                                                    \
  public:                                                                       \
    e_forceinline_always void set##X( const T a##X[ u32( N )]){                 \
      if( std::is_pod<T>() ){                                                   \
        memcpy( m_a##X, a##X, sizeof( T )*u32( N ));                            \
      }else{                                                                    \
        for( u32 i=0; i<u32( N ); ++i ){                                        \
          m_a##X[ i ]=a##X[ i ];                                                \
        }                                                                       \
      }                                                                         \
    }                                                                           \
    template<typename E> e_forceinline_always void setIn##X( const E e,         \
        const T& t ){                                                           \
      m_a##X[ u32( e )] = t;                                                    \
    }                                                                           \
    template<typename E> e_forceinline_always const T& in##X( const E e )const{ \
      e_assert( u32( e ) < u32( N ));                                           \
      return m_a##X[ u32( e )];                                                 \
    }                                                                           \
    template<typename E> e_forceinline_always T& in##X( const E e ){            \
      e_assert( u32( e ) < u32( N ));                                           \
      return m_a##X[ u32( e )];                                                 \
    }                                                                           \
    e_forceinline_always const T* to##X()const{                                 \
      return m_a##X;                                                            \
    }                                                                           \
    e_forceinline_always T* to##X(){                                            \
      return m_a##X;                                                            \
    }                                                                           \
  private:                                                                      \
    T m_a##X[ u32( N )]                                                         \

#define e_var_dim1( T, N )                                                      \
  e_var_dim( T, T##s, N )                                                       \

      //}:                                        |
      //e_var_pool:{                              |

#define e_var_pool( T, X, N )                                                   \
  public:                                                                       \
    using X=::EON::gfc::pool<T,N>;                                              \
    e_forceinline_always void setIn##X( const u32 i, const T& t ){              \
      m_t##X.set( i, t );                                                       \
    }                                                                           \
    e_forceinline_always const T& in##X( const u32 i )const{                    \
      return m_t##X[i];                                                         \
    }                                                                           \
    e_forceinline_always T& in##X( const u32 i ){                               \
      return m_t##X[i];                                                         \
    }                                                                           \
    e_forceinline_always const X& to##X()const{                                 \
      return m_t##X;                                                            \
    }                                                                           \
    e_forceinline_always X& to##X(){                                            \
      return m_t##X;                                                            \
    }                                                                           \
    e_forceinline_always void clear##X(){                                       \
      m_t##X.clear();                                                           \
    }                                                                           \
  private:                                                                      \
    X m_t##X                                                                    \

#define e_var_pool1( T, N )                                                     \
  e_var_pool( T, T##s, N )                                                      \

      //}:                                        |
      //e_var_hashmap:{                           |

        /** \brief Define hashmap var.
          *
          * This macro will create a hashmap member variable. It's identical in
          * many ways to e_var_handle() but also adds a in* function that takes
          * an integer index, which returns an element of the map. The
          * following methods are created for you if T equals string and X
          * equals Strings or in other words e_var_map( string, Strings );
          *
          * \param K The key for each element in the new map variable.
          * \param T The type of each element in the new map variable.
          * \param X The name of the undecorated variable.
          */

#define e_var_hashmap( K, T, X )                                                \
  public:                                                                       \
    using X=::EON::gfc::hashmap<K,T>;                                           \
    e_forceinline_always void setIn##X( const K key, const T& t ){              \
      m_m##X.set( key, t );                                                     \
    }                                                                           \
    e_forceinline_always void setBy##X( const K key                             \
        , const std::function<void( T& )>& lambda ){                            \
      m_m##X.setBy( key, lambda );                                              \
    }                                                                           \
    e_forceinline_always const T in##X( const K key )const{                     \
      if( m_m##X.find( key )){                                                  \
        return m_m##X[ key ];                                                   \
      }                                                                         \
      return T();                                                               \
    }                                                                           \
    e_forceinline_always void set##X( const X& m##X ){                          \
      m_m##X = m##X;                                                            \
    }                                                                           \
    e_forceinline_always void set##X( X&& m##X ){                               \
      m_m##X = std::move( m##X );                                               \
    }                                                                           \
    e_forceinline_always const X& to##X()const{                                 \
      return m_m##X;                                                            \
    }                                                                           \
    e_forceinline_always X& to##X(){                                            \
      return m_m##X;                                                            \
    }                                                                           \
    e_forceinline_always void clear##X(){                                       \
      m_m##X.clear();                                                           \
    }                                                                           \
  private:                                                                      \
    X m_m##X                                                                    \

#define e_var_hashmap1( K, T )                                                  \
  e_var_hashmap( K, T, T##s )                                                   \

      //}:                                        |
      //e_var_map:{                               |

        /** \brief Define map var.
          *
          * This macro will create a map member variable. It is identical in
          * many ways to e_var_handle() but also adds a in* function that takes
          * an integer index, which returns an element of the map. The
          * following methods are created for you if T equals string and X
          * equals Strings or in other words e_var_map( string, Strings );
          *
          * \param K The key for each element in the new map variable.
          * \param T The type of each element in the new map variable.
          * \param X The name of the undecorated variable.
          */

#define e_var_map( K, T, X )                                                    \
  public:                                                                       \
    using X=::EON::gfc::map<K,T>;                                               \
    e_forceinline_always void setBy##X( const K key                             \
        , const std::function<void( T& )>& lambda ){                            \
      m_m##X.setBy( key, lambda );                                              \
    }                                                                           \
    e_forceinline_always void setIn##X( const K& key, const T& t ){             \
      m_m##X.set( key, t );                                                     \
    }                                                                           \
    e_forceinline_always const T in##X( const K& key )const{                    \
      if( m_m##X.find( key )){                                                  \
        return m_m##X[ key ];                                                   \
      }                                                                         \
      return T();                                                               \
    }                                                                           \
    e_forceinline_always void set##X( const X& m##X ){                          \
      m_m##X = m##X;                                                            \
    }                                                                           \
    e_forceinline_always void set##X( X&& m##X ){                               \
      m_m##X = std::move( m##X );                                               \
    }                                                                           \
    e_forceinline_always const X& to##X()const{                                 \
      return m_m##X;                                                            \
    }                                                                           \
    e_forceinline_always X& to##X(){                                            \
      return m_m##X;                                                            \
    }                                                                           \
    e_forceinline_always void clear##X(){                                       \
      m_m##X.clear();                                                           \
    }                                                                           \
  private:                                                                      \
    X m_m##X                                                                    \

#define e_var_map1( K, T )                                                      \
  e_var_map( K, T, T##s )                                                       \

      //}:                                        |
      //e_var_handle_hashmap:{                    |

        /** \brief Define hashmap of handles var.
          *
          * This macro will create a hashmap of handles member variable with
          * all the associated accessors including const correct ones. It will
          * define the following member functions if T=Texture and X=Maps or in
          * other words e_var_handle_hashmap( Texture, Maps ); The type
          * generated by this macro is thread safe.
          *
          * \param T The type of handle: T must have an e_reflect() statement
          * in it and be derived ultimately from gfc::Object.
          * \param X The name of the new variable. The full decorated name will
          * be m_mX where X is a C name. The first letter should be
          * capitalized.
          */

#define e_var_handle_hashmap( K, T, X )                                         \
  public:                                                                       \
    using X=::EON::gfc::hashmap<K,::EON::gfc::AutoRef<T>>;                      \
    e_forceinline_always void setIn##X( const K key,                            \
        const::EON::gfc::AutoRef<T>& h ){                                       \
      m_m##X.set( key, h );                                                     \
    }                                                                           \
    e_forceinline_always void setBy##X( const K key                             \
        , const std::function<void(::EON::gfc::AutoRef<T>& )>& lambda ){        \
      m_m##X.setBy( key, lambda );                                              \
    }                                                                           \
    e_forceinline_always::EON::gfc::AutoRef<T> in##X( const K key )const{       \
      if( m_m##X.find( key )){                                                  \
        return m_m##X[ key ];                                                   \
      }                                                                         \
      return 0;                                                                 \
    }                                                                           \
    e_forceinline_always void set##X( const X& x ){                             \
      m_m##X = x;                                                               \
    }                                                                           \
    e_forceinline_always void set##X( X&& x ){                                  \
      m_m##X = std::move( x );                                                  \
    }                                                                           \
    e_forceinline_always const X& to##X()const{                                 \
      return m_m##X;                                                            \
    }                                                                           \
    e_forceinline_always X& to##X(){                                            \
      return m_m##X;                                                            \
    }                                                                           \
    e_forceinline_always void clear##X(){                                       \
      m_m##X.clear();                                                           \
    }                                                                           \
  private:                                                                      \
    X m_m##X                                                                    \

#define e_var_handle_hashmap1( K, T )                                           \
  e_var_handle_hashmap( K, T, T##s )                                            \

      //}:                                        |
      //e_var_handle_vector:{                     |

        /** \brief Define vector of handles var.
          *
          * This macro will create a vector of handles member variable with all
          * the associated accessors including const correct ones. It will
          * define the following member functions if T=Texture and X=Maps or in
          * other words e_var_handle_vector( Texture, Maps ); The type
          * generated by
          * this macro is thread safe.
          *
          * \param T The type of handle: T must have an e_reflect() statement
          * in it and be derived ultimately from gfc::Object.
          * \param X The name of the new variable. The full decorated name will
          * be m_vX where X is a C name. The first letter should be
          * capitalized.
          */

#define e_var_handle_vector( T, X )                                             \
  public:                                                                       \
    using X=::EON::gfc::vector<::EON::gfc::AutoRef<T>>;                         \
    template<typename C> e_forceinline_always bool sort##X(                     \
          const std::function<C>& lambda ){                                     \
      return m_v##X.sort( lambda );                                             \
    }                                                                           \
    template<typename C> e_forceinline_always bool sort##X( const C& functor ){ \
      return m_v##X.sort( functor );                                            \
    }                                                                           \
    template<typename E> e_forceinline_always void setIn##X( const E e,         \
        const::EON::gfc::AutoRef<T>& h ){                                       \
      m_v##X.set( e, h );                                                       \
    }                                                                           \
    template<typename E> e_forceinline_always::EON::gfc::AutoRef<T> in##X(      \
        const E e )const{                                                       \
      return m_v##X[ u32( e )];                                                 \
    }                                                                           \
    e_forceinline_always void set##X( const X& x ){                             \
      m_v##X = x;                                                               \
    }                                                                           \
    e_forceinline_always void set##X( X&& x ){                                  \
      m_v##X = std::move( x );                                                  \
    }                                                                           \
    e_forceinline_always const X& to##X()const{                                 \
      return m_v##X;                                                            \
    }                                                                           \
    e_forceinline_always X& to##X(){                                            \
      return m_v##X;                                                            \
    }                                                                           \
    e_forceinline_always void clear##X(){                                       \
      m_v##X.clear();                                                           \
    }                                                                           \
  private:                                                                      \
    X m_v##X                                                                    \

#define e_var_handle_vector1( T )                                               \
  e_var_handle_vector( T, T##s )                                                \

      //}:                                        |
      //e_var_handle_array:{                      |

        /** \brief Define array of handles.
          *
          * This macro will create an array of handles member variable with all
          * the necessary accessors to be considered const correct. It will
          * generate the following code in your class if T=Texture, X=Maps and
          * N=10.
          \code
          public:
            typedef Texture::handle MapsType;
          protected:
            MapsType m_aMaps[10];
          public:
            u32 toMapsCapacity()const;
            void setMaps( const MapsType x[10] );
            void setInMaps( u32 i, const MapsType& x );
            const MapsType& inMaps( u32 i )const;
            MapsType& inMaps( u32 i );
            const MapsType* toMaps()const;
            MapsType toMaps();
            void clearMaps();
          \endcode
          * \param T The type of each element in the array. T must be a class
          * that inherits at some level the gfc::Object class and has an
          * e_reflect() statement. Each element will use the T's handle type.
          * \param X The undecorated name of the member variable. If X is Bobs
          * then the variable name will be m_aBobs.
          * \param N The number of handle elements in the array.
          */

#define e_var_handle_array( T, X, N )                                           \
  public:                                                                       \
    using X=::EON::gfc::array<::EON::gfc::AutoRef<T>,u32( N )>;                 \
    static const u32 k##X##Capacity = u32( N );                                 \
    e_forceinline_always void set##X( const X& x ){                             \
      m_a##X = x;                                                               \
    }                                                                           \
    e_forceinline_always void set##X( X&& x ){                                  \
      m_a##X = std::move( x );                                                  \
    }                                                                           \
    template<typename E> e_forceinline_always void setIn##X( const E e,         \
        const::EON::gfc::AutoRef<T>& h ){                                       \
      m_a##X[ u32( e )] = h;                                                    \
    }                                                                           \
    template<typename E> e_forceinline_always const::EON::gfc::AutoRef<T>&      \
        in##X( const E e )const{                                                \
      return m_a##X[ e ];                                                       \
    }                                                                           \
    template<typename E> e_forceinline_always::EON::gfc::AutoRef<T>& in##X(     \
        const E e ){                                                            \
      return m_a##X[ e ];                                                       \
    }                                                                           \
    e_forceinline_always const X& to##X()const{                                 \
      return m_a##X;                                                            \
    }                                                                           \
    e_forceinline_always X& to##X(){                                            \
      return m_a##X;                                                            \
    }                                                                           \
    e_forceinline_always void clear##X(){                                       \
      for( u32 i=0; i<u32( N ); ++i ){                                          \
        m_a##X[ i ] = 0;                                                        \
      }                                                                         \
    }                                                                           \
  private:                                                                      \
    X m_a##X                                                                    \

#define e_var_handle_array1( T, N )                                             \
  e_var_handle_array( T, T##s, N )                                              \

      //}:                                        |
      //e_var_handle_pool:{                       |

#define e_var_handle_pool( T, X, N )                                            \
  public:                                                                       \
    using X=::EON::gfc::pool<::EON::gfc::AutoRef<T>,N>;                         \
    template<typename E> e_forceinline_always void setIn##X( const E e,         \
        const::EON::gfc::AutoRef<T>& h ){                                       \
      m_t##X.set( u32( e ), h );                                                \
    }                                                                           \
    template<typename E> e_forceinline_always::EON::gfc::AutoRef<T> in##X(      \
        const E e )const{                                                       \
      return m_t##X[ u32( e )];                                                 \
    }                                                                           \
    e_forceinline_always void set##X( const X& x ){                             \
      m_t##X = x;                                                               \
    }                                                                           \
    e_forceinline_always void set##X( X&& x ){                                  \
      m_t##X = std::move( x );                                                  \
    }                                                                           \
    e_forceinline_always const X& to##X()const{                                 \
      return m_t##X;                                                            \
    }                                                                           \
    e_forceinline_always X& to##X(){                                            \
      return m_t##X;                                                            \
    }                                                                           \
    e_forceinline_always void clear##X(){                                       \
      m_t##X.clear();                                                           \
    }                                                                           \
  private:                                                                      \
    X m_t##X                                                                    \

#define e_var_handle_pool1( T,N )                                               \
  e_var_handle_pool( T, T##s, N )                                               \

      //}:                                        |
      //e_var_handle_map:{                        |

        /** \brief Define map of handles var.
          *
          * This macro will create a map of handles member variable with all
          * the associated accessors including const correct ones. It will
          * define the following member functions if T=Texture and X=Maps or in
          * other words e_var_handle_map( Texture, Maps ); The type
          * generated by
          * this macro is thread safe.
          *
          * \param T The type of handle: T must have an e_reflect() statement
          * in it and be derived ultimately from gfc::Object.
          * \param X The name of the new variable. The full decorated name will
          * be m_mX where X is a C name. The first letter should be
          * capitalized.
          */

#define e_var_handle_map( K, T, X )                                             \
  public:                                                                       \
    using X=::EON::gfc::map<AutoRef<T>>;                                        \
    e_forceinline_always void setIn##X( const K& key,                           \
        const::EON::gfc::AutoRef<T>& h ){                                       \
      m_m##X.set( key, h );                                                     \
    }                                                                           \
    e_forceinline_always void setBy##X( const K key                             \
        , const std::function<void(::EON::gfc::AutoRef<T>& )>& lambda ){        \
      m_m##X.setBy( key, lambda );                                              \
    }                                                                           \
    e_forceinline_always::EON::gfc::AutoRef<T> in##X( const Key& key )const{    \
      if( m_m##X.find( key )){                                                  \
        return m_m##X[ key ];                                                   \
      }                                                                         \
      return 0;                                                                 \
    }                                                                           \
    e_forceinline_always void set##X( const X& x ){                             \
      m_m##X = x;                                                               \
    }                                                                           \
    e_forceinline_always void set##X( X&& x ){                                  \
      m_m##X = std::move( x );                                                  \
    }                                                                           \
    e_forceinline_always const X& to##X()const{                                 \
      return m_m##X;                                                            \
    }                                                                           \
    e_forceinline_always X& to##X(){                                            \
      return m_m##X;                                                            \
    }                                                                           \
    e_forceinline_always void clear##X(){                                       \
      m_m##X.clear();                                                           \
    }                                                                           \
  private:                                                                      \
    X m_m##x                                                                    \

#define e_var_handle_map1( K, T )                                               \
  e_var_handle_map( K, T, T##s )                                                \

      //}:                                        |
      //e_var_const_ptr_vector:{                  |

        /** \brief Define vector of pointers.
          *
          * This macro will create a vector of pointers member variable with
          * all the accessors you'd expect for good const correct software. It
          * will generate the following member functions if T=Texture and
          * X=Maps:
          \code
          public:
            typedef gfc::vector<T*> Maps;
          protected:
            Maps m_vMaps;
          public:
            Texture* inMaps( const int i )const;
            Texture*& inMaps( const int i );
            const Maps& toMaps()const;
            Maps& toMaps();
            void clearMaps();
          \endcode
          * \param T The type pointed to by m_vMaps.
          * \param X The undecorated name of the member variable. First letter
          * should be capitalized.
          */

#define e_var_const_ptr_vector( T, X )                                          \
  public:                                                                       \
    using X=::EON::gfc::vector<const T*>;                                       \
    template<typename C> e_forceinline_always bool sort##X(                     \
          const std::function<C>& lambda ){                                     \
      return m_v##X.sort( lambda );                                             \
    }                                                                           \
    template<typename C> e_forceinline_always bool sort##X( const C& functor ){ \
      return m_v##X.sort( functor );                                            \
    }                                                                           \
    template<typename E> e_forceinline_always void setIn##X( const E e, T* p ){ \
      m_v##X.set( e, p );                                                       \
    }                                                                           \
    template<typename E> e_forceinline_always const T* in##X( const E e )const{ \
      return m_v##X[ e ];                                                       \
    }                                                                           \
    e_forceinline_always const X& to##X()const{                                 \
      return m_v##X;                                                            \
    }                                                                           \
    e_forceinline_always void clear##X(){                                       \
      m_v##X.clear();                                                           \
    }                                                                           \
  private:                                                                      \
    X m_v##X                                                                    \

      //}:                                        |
      //e_var_ptr_vector:{                        |

        /** \brief Define vector of pointers.
          *
          * This macro will create a vector of pointers member variable with
          * all the accessors you'd expect for good const correct software. It
          * will generate the following member functions if T=Texture and
          * X=Maps:
          \code
          public:
            typedef gfc::vector<T*> Maps;
          protected:
            Maps m_vMaps;
          public:
            Texture* inMaps( const int i )const;
            Texture*& inMaps( const int i );
            const Maps& toMaps()const;
            Maps& toMaps();
            void clearMaps();
          \endcode
          * \param T The type pointed to by m_vMaps.
          * \param X The undecorated name of the member variable. First letter
          * should be capitalized.
          */

#define e_var_ptr_vector( T, X )                                                \
  public:                                                                       \
    using X=::EON::gfc::vector<T*>;                                             \
    e_forceinline_always bool sort##X(                                          \
          const std::function<bool( const T* a, const T* b )>& lambda ){        \
      return m_v##X.sort( lambda );                                             \
    }                                                                           \
    template<typename C> e_forceinline_always bool sort##X( const C& functor ){ \
      return m_v##X.sort( functor );                                            \
    }                                                                           \
    template<typename E> e_forceinline_always void setIn##X( const E e, T* p ){ \
      m_v##X.set( e, p );                                                       \
    }                                                                           \
    template<typename E> e_forceinline_always const T* in##X( const E e )const{ \
      return m_v##X[ e ];                                                       \
    }                                                                           \
    e_forceinline_always const X& to##X()const{                                 \
      return m_v##X;                                                            \
    }                                                                           \
    e_forceinline_always X& to##X(){                                            \
      return m_v##X;                                                            \
    }                                                                           \
    e_forceinline_always void clear##X(){                                       \
      m_v##X.clear();                                                           \
    }                                                                           \
  private:                                                                      \
    X m_v##X                                                                    \

#define e_var_ptr_vector1( T )                                                  \
  e_var_ptr_vector( T, T##s )                                                   \

      //}:                                        |
      //e_var_const_ptr_array1:{                  |

#define e_var_const_ptr_array1( T, N )                                          \
  e_var_const_ptr_array( T, T##s, N )                                           \

      //}:                                        |
      //e_var_ptr_array1:{                        |

        /** \brief Define array of pointers member variable.
          *
          * This macro will code generate a member variable array of N elements
          * where each element is a pointer. It will also generate all the
          * proper accessors (setters and getters) plus in* element accessors.
          * The scope immediately following this macro's use will be public.
          \code
            class ThreadFarm{
              e_var_ptr_array1( Thread, 100 );
              ThreadFarm& operator=( const ThreadFarm& threadFarm ) = delete;
              ThreadFarm& operator=( ThreadFarm&& threadFarm ) = delete;
              ThreadFarm( ThreadFarm&& threadFarm ){
                for( u32 i=0; i<kMaxThreads; ++i ){
                  m_aThreads[i] = threadFarm.m_aThreads[i];
                  threadFarm.m_aThreads[i] = 0;
                }
              }
              ThreadFarm()=default;
            };
          \endcode
          *
          * The preceding code will expand to a pretty large number of methods.
          *
          \code
            class ThreadFarm{
            protected:
              Thread* m_aThreads[100];
            public:
              static const u32 kMaxThreads;
              e_forceinline_always void setThreads( Thread* a[100] ){
                for( u32 i=0; i<100; ++i ){
                  m_aThreads[i] = a[i];
                }
              }
              e_forceinline_always void setInThreads( const u32 i, Thread* p ){
                e_assert( i < N );
                m_aThreads[i] = p;
              }
              e_forceinline_always const T* inThreads( const u32 i )const{
                e_assert( i < N );
                return m_aThreads[i];
              }
              e_forceinline_always T* inThreads( const u32 i ){
                e_assert( i < N );
                return m_aThreads[i];
              }
              e_forceinline_always const Thread** toThreads()const{
                return m_aThreads;
              }
              e_forceinline_always Thread** toThreads(){
                return m_aThreads;
              }
              e_forceinline_always void clearThreads(){
                for( u32 i=0; i<100; ++i ){
                  m_aThreads[i] = nullptr;
                }
              }
              ...
            };
          \endcode
          */

#define e_var_ptr_array1( T, N )                                                \
  e_var_ptr_array( T, T##s, N )                                                 \

      //}:                                        |
      //e_var_ptr_array:{                         |

#define e_var_ptr_array( T, X, N )                                              \
  public:                                                                       \
    using X=::EON::gfc::array<T*,N>;                                            \
    static const u32 kMax##X;                                                   \
    template<typename E> e_forceinline_always void setIn##X( const E e, T* p ){ \
      m_a##X[ u32( e )] = p;                                                    \
    }                                                                           \
    template<typename E> e_forceinline_always const T* in##X( const E e )const{ \
      return m_a##X[ u32( e )];                                                 \
    }                                                                           \
    template<typename E> e_forceinline_always T*& in##X( const E e ){           \
      return m_a##X[ u32( e )];                                                 \
    }                                                                           \
    e_forceinline_always void set##X( const X& a ){                             \
      m_a##X = a;                                                               \
    }                                                                           \
    e_forceinline_always void set##X( X&& a ){                                  \
      m_a##X = std::move( a );                                                  \
    }                                                                           \
    e_forceinline_always const X& to##X()const{                                 \
      return m_a##X;                                                            \
    }                                                                           \
    e_forceinline_always void clear##X(){                                       \
      for( u32 i=0; i<u32( N ); ++i ){                                          \
        m_a##X[i] = nullptr;                                                    \
      }                                                                         \
    }                                                                           \
    e_forceinline_always X& to##X(){                                            \
      return m_a##X;                                                            \
    }                                                                           \
  private:                                                                      \
    X m_a##X                                                                    \

      //}:                                        |
      //e_var_color:{                             |

#define e_var_color( X )                                                        \
  public:                                                                       \
    e_forceinline_always void set##X( const rgba& c##X ){                       \
      m_c##X = c##X;                                                            \
    }                                                                           \
    e_forceinline_always bool is##X( const rgba& col )const{                    \
      return( m_c##X == col );                                                  \
    }                                                                           \
    e_forceinline_always const rgba& to##X()const{                              \
      return m_c##X;                                                            \
    }                                                                           \
    e_forceinline_always void to##X( rgba& c ){                                 \
      m_c##X = c;                                                               \
    }                                                                           \
    e_forceinline_always rgba& to##X(){                                         \
      return m_c##X;                                                            \
    }                                                                           \
  private:                                                                      \
    rgba m_c##X                                                                 \

      //}:                                        |
      //e_var_private_volatile_bits:{             |

#define e_var_private_volatile_bits( X,...)                                     \
  private:                                                                      \
    union X{ u64 all;                                                           \
      struct Bitmap{                                                            \
        u64 __VA_ARGS__;                                                        \
      };                                                                        \
      X( const volatile X& t )                                                  \
        : all( t.all )                                                          \
      {}                                                                        \
      X()                                                                       \
        : all( 0ULL )                                                           \
      {}                                                                        \
    private:                                                                    \
      e_var1( t, Bitmap );                                                      \
    public:                                                                     \
      e_forceinline_always void operator=( const volatile X& x )volatile{       \
        all = x.all;                                                            \
      }                                                                         \
      e_forceinline_always const volatile Bitmap* operator->()const volatile{   \
        return &m_tBitmap;                                                      \
      }                                                                         \
      e_forceinline_always volatile Bitmap* operator->()volatile{               \
        return &m_tBitmap;                                                      \
      }                                                                         \
      e_forceinline_always void clear()volatile{                                \
        all = 0ULL;                                                             \
      }                                                                         \
    };                                                                          \
    e_forceinline_always void set##X( const volatile X& t ){                    \
      m_t##X = t;                                                               \
    }                                                                           \
    e_forceinline_always const volatile X& to##X()const{                        \
      return m_t##X;                                                            \
    }                                                                           \
    e_forceinline_always volatile X& to##X(){                                   \
      return m_t##X;                                                            \
    }                                                                           \
    e_forceinline_always void clear##X(){                                       \
      m_t##X.clear();                                                           \
    }                                                                           \
  private:                                                                      \
    volatile X m_t##X                                                           \

      //}:                                        |
      //e_var_volatile_bits:{                     |

#define e_var_volatile_bits( X,...)                                             \
  public:                                                                       \
    union X{ u64 all;                                                           \
      struct Bitmap{                                                            \
        u64 __VA_ARGS__;                                                        \
      };                                                                        \
      X( volatile X&& x )                                                       \
          : all( x.all ){                                                       \
        x.all = 0ULL;                                                           \
      }                                                                         \
      X( const volatile X& x )                                                  \
        : all( x.all )                                                          \
      {}                                                                        \
      X( const u64 a )                                                          \
        : all( a )                                                              \
      {}                                                                        \
      X()                                                                       \
        : all( 0ULL )                                                           \
      {}                                                                        \
    private:                                                                    \
      e_var1( t, Bitmap );                                                      \
    public:                                                                     \
      e_forceinline_always const volatile Bitmap* operator->()const volatile{   \
        return &m_tBitmap;                                                      \
      }                                                                         \
      e_forceinline_always void operator=( const volatile X& x )volatile{       \
        all = x.all;                                                            \
      }                                                                         \
      e_forceinline_always volatile Bitmap* operator->()volatile{               \
        return &m_tBitmap;                                                      \
      }                                                                         \
      e_forceinline_always void clear()volatile{                                \
        all = 0ULL;                                                             \
      }                                                                         \
    };                                                                          \
    e_forceinline_always void set##X( const volatile X& t ){                    \
      m_t##X = t;                                                               \
    }                                                                           \
    e_forceinline_always const volatile X& to##X()const{                        \
      return m_t##X;                                                            \
    }                                                                           \
    e_forceinline_always volatile X& to##X(){                                   \
      return m_t##X;                                                            \
    }                                                                           \
    e_forceinline_always void clear##X(){                                       \
      m_t##X.clear();                                                           \
    }                                                                           \
  private:                                                                      \
    volatile X m_t##X                                                           \

      //}:                                        |
      //e_var_private_bits:{                      |

#define e_var_private_bits( X,...)                                              \
  private:                                                                      \
    union X final{ u64 all;                                                     \
      struct Bitmap{                                                            \
        u64 __VA_ARGS__;                                                        \
      };                                                                        \
      X( const X& x )                                                           \
        : all( x.all )                                                          \
      {}                                                                        \
      X( const u64 a )                                                          \
        : all( a )                                                              \
      {}                                                                        \
      X()                                                                       \
        : all( 0ULL )                                                           \
      {}                                                                        \
    private:                                                                    \
      e_var1( t, Bitmap );                                                      \
    public:                                                                     \
      e_forceinline_always void operator=( const X& x ){                        \
        all = x.all;                                                            \
      }                                                                         \
      e_forceinline_always const Bitmap* operator->()const{                     \
        return &m_tBitmap;                                                      \
      }                                                                         \
      e_forceinline_always Bitmap* operator->(){                                \
        return &m_tBitmap;                                                      \
      }                                                                         \
      e_forceinline_always void clear(){                                        \
        all = 0ULL;                                                             \
      }                                                                         \
    };                                                                          \
    e_forceinline_always void set##X( const X& t ){                             \
      m_t##X = t;                                                               \
    }                                                                           \
    e_forceinline_always const X& to##X()const{                                 \
      return m_t##X;                                                            \
    }                                                                           \
    e_forceinline_always X& to##X(){                                            \
      return m_t##X;                                                            \
    }                                                                           \
    e_forceinline_always void clear##X(){                                       \
      m_t##X.clear();                                                           \
    }                                                                           \
  private:                                                                      \
    X m_t##X                                                                    \

      //}:                                        |
      //e_var_bits:{                              |

#define e_var_bits( X,...)                                                      \
  public:                                                                       \
    union X final{ u64 all;                                                     \
      struct Bitmap{                                                            \
        u64 __VA_ARGS__;                                                        \
      };                                                                        \
      X( const X& x )                                                           \
        : all( x.all )                                                          \
      {}                                                                        \
      X( X&& x )                                                                \
          : all( x.all ){                                                       \
        x.all = 0ULL;                                                           \
      }                                                                         \
      X(){                                                                      \
        all = 0ULL;                                                             \
      }                                                                         \
    private:                                                                    \
      e_var1( t, Bitmap );                                                      \
    public:                                                                     \
      e_forceinline_always bool operator==( const X& x ){                       \
        return( x.all == all );                                                 \
      }                                                                         \
      e_forceinline_always bool operator!=( const X& x ){                       \
        return( x.all != all );                                                 \
      }                                                                         \
      e_forceinline_always bool operator<=( const X& x ){                       \
        return( x.all <= all );                                                 \
      }                                                                         \
      e_forceinline_always bool operator<( const X& x ){                        \
        return( x.all < all );                                                  \
      }                                                                         \
      e_forceinline_always bool operator>=( const X& x ){                       \
        return( x.all >= all );                                                 \
      }                                                                         \
      e_forceinline_always bool operator>( const X& x ){                        \
        return( x.all > all );                                                  \
      }                                                                         \
      e_forceinline_always X& operator=( const X& x ){                          \
        all = x.all;                                                            \
        return *this;                                                           \
      }                                                                         \
      e_forceinline_always const Bitmap* operator->()const{                     \
        return &m_tBitmap;                                                      \
      }                                                                         \
      e_forceinline_always Bitmap* operator->(){                                \
        return &m_tBitmap;                                                      \
      }                                                                         \
      e_forceinline_always X& operator=( X&& x ){                               \
        all = x.all;                                                            \
        x.all = 0ULL;                                                           \
        return *this;                                                           \
      }                                                                         \
      e_forceinline_always operator u64()const{                                 \
        return all;                                                             \
      }                                                                         \
      e_forceinline_always void clear(){                                        \
        all = 0ULL;                                                             \
      }                                                                         \
    };                                                                          \
    e_forceinline_always void set##X( const X& t ){                             \
      m_t##X = t;                                                               \
    }                                                                           \
    e_forceinline_always const X& to##X()const{                                 \
      return m_t##X;                                                            \
    }                                                                           \
    e_forceinline_always void clear##X(){                                       \
      m_t##X.clear();                                                           \
    }                                                                           \
    e_forceinline_always X& to##X(){                                            \
      return m_t##X;                                                            \
    }                                                                           \
  private:                                                                      \
    X  m_t##X                                                                   \

      //}:                                        |
      //e_var_union_of_bits:{                     |

#define e_var_union_of_bits( X,... )                                            \
  public:                                                                       \
    union X final{                                                              \
      e_forceinline_always void clear(){                                        \
        all = 0ULL;                                                             \
      }                                                                         \
      X& operator=( const X& x ){                                               \
        memcpy( this, &x, sizeof( X ));                                         \
        return *this;                                                           \
      }                                                                         \
      X()                                                                       \
        : all( 0ULL )                                                           \
      {}                                                                        \
      __VA_ARGS__;                                                              \
      u64 all;                                                                  \
    };                                                                          \
    e_forceinline_always void set##X( const X& t ){                             \
      m_t##X = t;                                                               \
    }                                                                           \
    e_forceinline_always const X& to##X()const{                                 \
      return m_t##X;                                                            \
    }                                                                           \
    e_forceinline_always void clear##X(){                                       \
      m_t##X.clear();                                                           \
    }                                                                           \
    e_forceinline_always X& to##X(){                                            \
      return m_t##X;                                                            \
    }                                                                           \
  private:                                                                      \
    X m_t##X{}                                                                  \

      //}:                                        |
      //e_var_union:{                             |

#define e_var_union( X,... )                                                    \
  public:                                                                       \
    union X final{                                                              \
      e_forceinline_always void clear(){                                        \
        memset( this, 0, sizeof( X ));                                          \
      }                                                                         \
      X& operator=( const X& x ){                                               \
        memcpy( this, &x, sizeof( X ));                                         \
        return *this;                                                           \
      }                                                                         \
      X(){}                                                                     \
      __VA_ARGS__;                                                              \
    };                                                                          \
    e_forceinline_always void set##X( const X& t ){                             \
      m_t##X = t;                                                               \
    }                                                                           \
    e_forceinline_always const X& to##X()const{                                 \
      return m_t##X;                                                            \
    }                                                                           \
    e_forceinline_always void clear##X(){                                       \
      m_t##X.clear();                                                           \
    }                                                                           \
    e_forceinline_always X& to##X(){                                            \
      return m_t##X;                                                            \
    }                                                                           \
  private:                                                                      \
    X m_t##X{}                                                                  \

      //}:                                        |
      //e_var_bool:{                              |

#define e_var_bool( X )                                                         \
  public:                                                                       \
    e_forceinline_always void set##X( bool b ){                                 \
      m_b##X = b;                                                               \
    }                                                                           \
    e_forceinline_always void disable##X(){                                     \
      m_b##X = false;                                                           \
    }                                                                           \
    e_forceinline_always void enable##X(){                                      \
      m_b##X = true;                                                            \
    }                                                                           \
    e_forceinline_always bool is##X( const bool val )const{                     \
      return( m_b##X == val );                                                  \
    }                                                                           \
    e_forceinline_always bool is##X()const{                                     \
      return m_b##X;                                                            \
    }                                                                           \
  private:                                                                      \
    bool m_b##X                                                                 \

      //}:                                        |
      //e_var_const_ref:{                         |

#define e_var_const_ref( T, X )                                                 \
  public:                                                                       \
    e_forceinline_always const T& to##X()const{                                 \
      return m_c##X;                                                            \
    }                                                                           \
  private:                                                                      \
    const T& m_c##X                                                             \

#define e_var_const_ref1( T )                                                   \
  e_var_ref( T, T )                                                             \

      //}:                                        |
      //e_var_ref:{                               |

#define e_var_ref( T, X )                                                       \
  public:                                                                       \
    e_forceinline_always void set##X( const T& refT ){                          \
      m_ref##X = refT;                                                          \
    }                                                                           \
    e_forceinline_always const T& to##X()const{                                 \
      return m_ref##X;                                                          \
    }                                                                           \
    e_forceinline_always T& to##X(){                                            \
      return m_ref##X;                                                          \
    }                                                                           \
  private:                                                                      \
    T& m_ref##X                                                                 \

#define e_var_ref1( T )                                                         \
  e_var_ref( T, T )                                                             \

      //}:                                        |
      //e_var_const_ptr:{                         |

#define e_var_const_ptr( T, X )                                                 \
  public:                                                                       \
    e_forceinline_always void set##X( const T* pT ){                            \
      m_p##X = pT;                                                              \
    }                                                                           \
    e_forceinline_always bool is##X( const T* ptr )const{                       \
      return( m_p##X == ptr );                                                  \
    }                                                                           \
    e_forceinline_always const T* to##X()const{                                 \
      return m_p##X;                                                            \
    }                                                                           \
  private:                                                                      \
    const T* m_p##X                                                             \

#define e_var_const_ptr1( T )                                                   \
  e_var_const_ptr( T, T )                                                       \

      //}:                                        |
      //e_var_shared_ptr:{                        |

#define e_var_shared_ptr( T, X )                                                \
  public:                                                                       \
    using X = std::shared_ptr<T>;                                               \
    e_forceinline_always void set##X( const X& ptr ){                           \
      m_p##X = ptr;                                                             \
    }                                                                           \
    e_forceinline_always bool is##X( const T* ptr )const{                       \
      return( m_p##X.get() == ptr );                                            \
    }                                                                           \
    e_forceinline_always bool is##X( const X& ptr )const{                       \
      return( m_p##X == ptr );                                                  \
    }                                                                           \
    e_forceinline_always X to##X()const{                                        \
      return m_p##X;                                                            \
    }                                                                           \
  private:                                                                      \
    X m_p##X                                                                    \

#define e_var_shared_ptr1( T )                                                  \
  e_var_shared_ptr( T, T )                                                      \

      //}:                                        |
      //e_var_unique_ptr:{                        |

#define e_var_unique_ptr( T, X )                                                \
  public:                                                                       \
    using X = std::unique_ptr<T>;                                               \
    e_forceinline_always void set##X( X&& uniquePtr ){                          \
      m_p##X = std::move( uniquePtr );                                          \
    }                                                                           \
    e_forceinline_always bool is##X( const T* ptr )const{                       \
      return( m_p##X.get() == ptr );                                            \
    }                                                                           \
    e_forceinline_always bool is##X( const X& ptr )const{                       \
      return( m_p##X == ptr );                                                  \
    }                                                                           \
    e_forceinline_always const X& to##X()const{                                 \
      return m_p##X;                                                            \
    }                                                                           \
    e_forceinline_always void move##X( X&& p##X ){                              \
      p##X = std::move( m_p##X );                                               \
    }                                                                           \
  private:                                                                      \
    X m_p##X                                                                    \

#define e_var_unique_ptr1( T )                                                  \
  e_var_unique_ptr( T, T )                                                      \

      //}:                                        |
      //e_var_ptr:{                               |

#define e_var_ptr( T, X )                                                       \
  public:                                                                       \
    e_forceinline_always void set##X( T* p ){                                   \
      m_p##X = p;                                                               \
    }                                                                           \
    e_forceinline_always bool is##X( const T* ptr )const{                       \
      return( m_p##X == ptr );                                                  \
    }                                                                           \
    e_forceinline_always const T* to##X()const{                                 \
      return m_p##X;                                                            \
    }                                                                           \
    e_forceinline_always T*& to##X(){                                           \
      return m_p##X;                                                            \
    }                                                                           \
  private:                                                                      \
    T* m_p##X                                                                   \

#define e_var_ptr1( T )                                                         \
  e_var_ptr( T, T )                                                             \

      //}:                                        |
      //e_var_const:{                             |

#define e_var_const( T, P, X )                                                  \
  public:                                                                       \
    e_forceinline_always bool is##X( const T& ref )const{                       \
      return( m_##P##X == ref );                                                \
    }                                                                           \
    e_forceinline_always const T& to##X()const{                                 \
      return m_##P##X;                                                          \
    }                                                                           \
  private:                                                                      \
    const T m_##P##X                                                            \

      //}:                                        |
      //e_var_enum:{                              |

        /** \brief Define enum member variable.
          *
          * This macro declares a member variable of the given enum type E. The
          * macro is defined in such a way that you can assign a default value
          * to it immediately after the declaration.
          *
          * \param E The type of the enum.
          * \param X The name of the enum. It will be decorated as m_eX where X
          * is a valid C identifier.
          */

#define e_var_enum( E, X )                                                      \
  public:                                                                       \
    template<typename T> e_forceinline_always void set##X( const T value ){     \
      m_e##X = E( value );                                                      \
    }                                                                           \
    e_forceinline_always bool is##X( const E e##X )const{                       \
      return( m_e##X == e##X );                                                 \
    }                                                                           \
    e_forceinline_always E to##X()const{                                        \
      return m_e##X;                                                            \
    }                                                                           \
    e_forceinline_always E& to##X(){                                            \
      return m_e##X;                                                            \
    }                                                                           \
  private:                                                                      \
    E m_e##X                                                                    \

        /** \brief Another enum member variable declaritor.
          *
          * This macro defines an enum in exactly the same way as e_var_enum
          * but when X and E are the same value. You cannot decorate E
          * obviously with :: because that would form a bad C identifier. This
          * form of the macro exists for all e_var* and e_property* macros as a
          * simplification and makes it easier to read.
          *
          * \param E The type of the enum.
          */

#define e_var_enum1( E )                                                        \
  e_var_enum( E, E )                                                            \

      //}:                                        |
      //e_var:{                                   |

        /** \brief Declare member variable.
          *
          * This macro will declare a member variable with the proper hungarian
          * notation for a member variable. It will prepend m_prefix to your
          * variable. The prefix you specify in the P macro argument, for
          * example e_var( string, s, MyString ) is an example of declaring a
          * string but a much better way (and the only engine approved manner
          * to declare a string) is to use e_var_string( MyString ) so you get
          * all the extra goodies that e_var_string() provides. The macro will
          * generate two toVarname() accessors, one for the const case and one
          * without, and one setVarname(value) method.
          *
          * The reason for providing the e_var* family of macros is so we can
          * have a consistent interface to members in the engine without having
          * to also declare all those pesky setters and getters as well.
          * Usually there are three methods you have to declare with every
          * member variable you add to a class: two gets (for const and
          * non-const) and one set. In the case of boolean types you may want
          * to have an is() method too for quickly seeing if your var is true
          * or false. For all these cases an e_var macro has been provided. In
          * the case of e_var_vector() additional methods are added for finding
          * elements in the vector or for clearing it out completely.
          *
          * The only drawback is that you cannot use tools like VisualAssist to
          * rename your variables globally, you must do it by hand. It's a bit
          * weird I realize and maybe a bit unreadable because you can't see by
          * reading the header files all the methods that are available to you
          * without memorizing the macros. The general rule of thumb is that
          * every e_var macro will produce setVarname() and toVarname(). All
          * the other methods are just helpful gravy.
          *
          * Please remember that like e_property* e_var* will declare all
          * member variables as protected and all methods as public. The scope
          * after the e_var* line will be changed to public as if you had said
          * public: in your header source.
          *
          * \param T The type of the member variable to declare.
          * \param P The prefix to the member variable. It will be named in
          * Hungarian notion as m_prefixVarname. Engine coding standards state
          * that a structure should be "t", a pointer "p", a string "s", a
          * reference "r", a vector "v", a map "m", and an array "a". For
          * pointers, vectors, maps, strings and arrays there exists a special
          * e_var_* (e_var_string or e_var_map for example) that adds the right
          * prefix for you and adds additional methods on a case by case basis.
          * A member variable declared with e_var_vector(), for example, will
          * add methods for finding elements in the vector and clearing it.
          * \param X The name of the variable. The name should be in mixed
          * case, so it starts with a capital letter.
          */

#define e_var_mutable( T, P, X )                                                \
  public:                                                                       \
    e_forceinline_always bool is##X( const T& in )const{                        \
      return( 0 == memcmp( cvp( &m_##P##X ), cvp( &in ), sizeof( T )));         \
    }                                                                           \
    e_forceinline_always void set##X( const T& t ){                             \
      m_##P##X = t;                                                             \
    }                                                                           \
    e_forceinline_always const T& to##X()const{                                 \
      return m_##P##X;                                                          \
    }                                                                           \
    e_forceinline_always T& to##X(){                                            \
      return m_##P##X;                                                          \
    }                                                                           \
  protected:                                                                    \
    mutable T m_##P##X                                                          \

#define e_var_mutable1( P, T )                                                  \
  e_var_mutable( T, P, T )                                                      \

#define e_var( T, P, X )                                                        \
  public:                                                                       \
    e_forceinline_always bool is##X( const T& in )const{                        \
      return( 0 == memcmp( cvp( &m_##P##X ), cvp( &in ), sizeof( T )));         \
    }                                                                           \
    e_forceinline_always void set##X( const T& t ){                             \
      m_##P##X = t;                                                             \
    }                                                                           \
    e_forceinline_always const T& to##X()const{                                 \
      return m_##P##X;                                                          \
    }                                                                           \
    e_forceinline_always T& to##X(){                                            \
      return m_##P##X;                                                          \
    }                                                                           \
  private:                                                                      \
    T m_##P##X                                                                  \

#define e_var1( P, T )                                                          \
  e_var( T, P, T )                                                              \

#define e_const_var( T, P, X )                                                  \
  public:                                                                       \
    e_forceinline_always bool is##X( const T& in )const{                        \
      return( 0 == memcmp( cvp( &m_##P##X ), cvp( &in ), sizeof( T )));         \
    }                                                                           \
    e_forceinline_always const T& to##X()const{                                 \
      return m_##P##X;                                                          \
    }                                                                           \
  private:                                                                      \
    const T m_##P##X                                                            \

#define e_const_var1( P, T )                                                    \
  e_const_var( T, P, T )                                                        \

      //}:                                        |
    //}:                                          |
  //}:                                            |
  //APIs:{                                        |
    //Compiler:{                                  |
      //e_compiling:{                             |

        /** \brief Compiler check macro.
          *
          * This routine will return 1 if the given label exists. The tag will
          * be formatted __label__.
          \code
            #if e_compiling( debug )
            #endif
          \endcode
          * \param x The label to check against.
          */

        #define e_compiling( x )                                                \
          __compiling_##x##__                                                   \

        #define e_condition( x, y )                                             \
          __condition_##x##__&& y                                               \

      //}:                                        |
      //64-bit or 32-bit:{                        |

        #ifdef __ARM_ARCH_ISA_A64
          #define __compiling_arm64__ 1
          #define __compiling_arm32__ 0
          #define __compiling_arm__   1
        #elif defined __ARM_ARCH_7S__ // armv7s
          #define __compiling_arm64__ 0
          #define __compiling_arm32__ 1
          #define __compiling_arm__   1
        #elif defined __ARM_ARCH_7A__ // arm7
          #define __compiling_arm64__ 0
          #define __compiling_arm32__ 1
          #define __compiling_arm__   1
        #elif defined __x86_64__ || defined _M_X64
          #define __compiling_x64__ 1
          #define __compiling_x86__ 0
        #else
          #define __compiling_x64__ 0
          #define __compiling_x86__ 1
        #endif

      //}:                                        |
      //e_forceinline_always:{                    |

        #ifdef _MSC_VER
          #define e_forceinline_always __forceinline
        #elif defined __llvm__
          #define e_forceinline_always inline __attribute__((__visibility__("hidden"),__always_inline__,__nodebug__))
        #else
          #define e_forceinline_always inline
        #endif

      //}:                                        |
      //e_forceinline:{                           |

        #ifdef _MSC_VER
          #define e_forceinline __forceinline
        #elif defined __llvm__
          #if e_compiling( debug )
            #define e_forceinline inline
          #else
            #define e_forceinline inline __attribute__((__visibility__("hidden"),__always_inline__,__nodebug__))
          #endif
        #else
          #define e_forceinline inline
        #endif

      //}:                                        |
      //e_noinline_or_debug:{                     |

        #ifdef _MSC_VER
          #define e_noinline_or_debug                                           \
            __declspec(noinline)
        #elif defined __llvm__
          #define e_noinline_or_debug                                           \
            __attribute__((__visibility__("hidden"),noinline,__nodebug__))
        #elif defined __GNUC__
          #define e_noinline_or_debug                                           \
            __attribute__((__visibility__("hidden"),noinline))
        #else
          #define e_noinline
        #endif

      //}:                                        |
      //e_noinline:{                              |

        #ifdef _MSC_VER
          #define e_noinline                                                    \
            __declspec(noinline)
        #elif defined __llvm__
          #define e_noinline                                                    \
            __attribute__((noinline))
        #else
          #define e_noinline
        #endif

      //}:                                        |
      //e_nodebug:{                               |

        #ifdef _MSC_VER
          #define e_nodebug
        #elif defined __llvm__
          #define e_nodebug                                                     \
            __attribute__((__visibility__("hidden"),__nodebug__))
        #else
          #define nodebug
        #endif

      //}:                                        |
      //e_noreturn:{                              |

        #ifdef _MSC_VER
          #define e_noreturn                                                    \
            __declspec(noreturn)
        #else
          #define e_noreturn                                                    \
            __attribute__((noreturn))
        #endif

      //}:                                        |
      //e_underlying:{                            |

        #ifdef __cplusplus

          /** \brief Get the underlying type of an enum class.
            *
            * This function will return the underlying type of an enum.
            */

          template<typename E> constexpr typename std::underlying_type<E>::type e_underlying( const E e ){
            return static_cast<typename std::underlying_type<E>::type>( e );
          }

        #endif

      //}:                                        |
      //e_friend:{                                |

        #define e_friend( x ) private:friend x

      //}:                                        |
      //e_join:{                                  |

        #define e_join( x, y ) x ## y

      //}:                                        |
      //e_paste:{                                 |

        #define e_token( x, y ) e_join( x, y )

      //}:                                        |
      //e_unique_label:{                          |

        #define e_distinct( x ) e_token( x,__LINE__)

      //}:                                        |
      //e_clog:{                                  |

        #define e_clog(__msg__)                                                 \
          e_pragma( message(__msg__))                                           \

      //}:                                        |
      //e_pragma:{                                |

        /** \def e_pragma
          *
          * \brief Macro to perform a pragma inside another macro.
          *
          * This macro is used for performing pragma statements from inside a
          * different macro just like you would with #pragma.
          *
          * \param st The pragma statement.
          */

        #ifdef _MSC_VER
          #define e_pragma( st )__pragma( st )
        #elif defined __clang__||defined c||defined __GNUC__
          #define e_pragma( st )_Pragma( #st )
        #endif

      //}:                                        |
      //e_todo:{                                  |

        /** \def e_todo
          *
          * \brief TODO macro.
          *
          * This macro will print a message in windows (line number safe) or a
          * warning in GCC and Clang in the format "TODO message". It's a good
          * way of reminding oneself about further work in the code.
          *
          * \param __msg__ The message to display in the compiler output.
          */

        #if e_compiling( microsoft )
          #define e_todo(__msg__)                                               \
            e_pragma( message(__FILE__ "(" e_2str(__LINE__) "):" __msg__))
        #else
          #define e_todo(__msg__)                                               \
            e_pragma( message(__msg__))
        #endif

      //}:                                        |
    //}:                                          |
    //Testing:{                                   |
      //e_testAssert:{                            |

        /** \brief Fire assertion from a unit test.
          *
          * This routine is used to fire an assertion if the unit test fails.
          */

        #define e_testAssert(x)                                                 \
          if( !(x) ){                                                           \
            e_logf( "Test failed: 0==("#x")" );                                 \
          DEBUG_BREAK                                                           \
          }                                                                     \

      //}:                                        |
      //e_unitTest:{                              |

        /** \brief Define a new unit test.
          *
          * This function macro will define a new unit test. It takes a name and
          * a function body which is the test itself.
          \code
            struct AllMine{
              bool foo();
              e_unitTest( Test1,
                AllMine a;
                e_testAssert( a.foo );
              );
            };
            int main(){
              e_runTest( AllMine, Test1 );
              return 0;
            }
          \endcode
          * \param X The name of the new test.
          */
        #define e_unitTest(X,...)                                               \
          static bool test##X##UnitTest(){                                      \
            __VA_ARGS__;                                                        \
            return true;                                                        \
          }

      //}:                                        |
      //e_runTest:{                               |

        /** \brief Run a unit test.
          *
          * This routine will execute a unit test on the given class.
          *
          \code
            int main(){
              e_runTest( AllMine, Test1 );
              return 0;
            }
          \endcode
          * \param T The class that has the unit test in it.
          * \param X The name of the test to run.
          */
        #define e_runTest(T,X)                                                  \
          e_testAssert( T::test##X##UnitTest() )                                \

      //}:                                        |
    //}:                                          |
    //Other:{                                     |
      //e_2str:{                                  |

        /** \brief Convert any literal to a string including __LINE__ and
          * numbers.
          *
          * This macro is used primarily for formatting pragma messages.
          * \param x The text to stringify.
          * \return A string.
          *
          \code
            #define e_clog(m)                                                   \
              __Pragma(e_2str(message(__FILE__"(" e_2str(__LINE__)"): " m)))
          \endcode
          */

        #define e_2str(x) _e_2str(x)

        /** \brief Convert unquoted text to a C string.
          *
          * This macro is the level of indirection that allowd e_2str to
          * convert a numerical value like __LINE__ to a string.
          *
          * \param x The text to stringify.
          * \return A string.
          */

        #define _e_2str(x) #x

      //}:                                        |
      //e_clamp:{                                 |

        #ifdef __cplusplus

          /** \brief Templatized clamp function.
            *
            * This routine will clamp the input type between min and max.
            *
            * \param x The value to clamp.
            * \param a The minimum value allowed.
            * \param b The maximum value allowed.
            */

          template<typename T> e_forceinline T e_clamp( const T x, const T a, const T b ){
            if( x < a ){
              return a;
            }
            if( x > b ){
              return b;
            }
            return x;
          }

        #endif

      //}:                                        |
      //e_min:{                                   |

        #ifdef __cplusplus

          /** \brief Templatized min function.
            *
            * This routine will return the minimum of two T values.
            *
            * \param a First value to compare.
            * \param b Second value to compare.
            *
            * \return Returns the smallest number out of a and b.
            */

          template<typename T> e_forceinline T e_min( const T a, const T b ){
            if( a < b ){
              return a;
            }
            return b;
          }

          /** \brief Three component templatized min function.
            *
            * This routine will return the minimum of three T values.
            *
            * \param a First value to compare.
            * \param b Second value to compare.
            * \param c Third value to compare.
            *
            * \return Returns the smallest number out of a, b and c.
            */

          template<typename T> e_forceinline T e_min( const T a, const T b, const T c ){
            const T t = e_min( a, b );
            if( t < c ){
              return t;
            }
            return c;
          }

        #endif

      //}:                                        |
      //e_max:{                                   |

        #ifdef __cplusplus

          /** \brief Templatized max function.
            *
            * This routine will return the maximum of two T values.
            *
            * \param a First value to compare.
            * \param b Second value to compare.
            *
            * \return Returns the largest number out of a and b.
            */

          template<typename T> e_forceinline T e_max( const T a, const T b ){
            if( a > b ){
              return a;
            }
            return b;
          }

          /** \brief Three component templatized max function.
            *
            * This routine will return the maximum of three T values.
            *
            * \param a First value to compare.
            * \param b Second value to compare.
            * \param c Third value to compare.
            *
            * \return Returns the largest number out of a, b and c.
            */

          template<typename T> e_forceinline T e_max( const T a, const T b, const T c ){
            const T t = e_max( a, b );
            if( t > c ){
              return t;
            }
            return c;
          }

        #endif

      //}:                                        |
    //}:                                          |
  //}:                                            |
  //u128:{                                        |

    #ifdef __cplusplus
      #include<boost/multiprecision/cpp_int.hpp>
      typedef boost::multiprecision::uint128_t u128;
    #endif

  //}:                                            |
//}:                                              |
//================================================+=============================

/**     @}
  *   @}
  * @}
  */
